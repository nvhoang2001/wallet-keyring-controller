{"version":3,"file":"KeyringController.js","sourceRoot":"","sources":["../src/KeyringController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TxData, TypedTransaction } from '@ethereumjs/tx';\nimport type {\n  MetaMaskKeyring as QRKeyring,\n  IKeyringState as IQRKeyringState,\n} from '@keystonehq/metamask-airgapped-keyring';\nimport type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseControllerV2 } from '@metamask/base-controller';\nimport { KeyringController as EthKeyringController } from '@metamask/eth-keyring-controller';\nimport type {\n  PersonalMessageParams,\n  TypedMessageParams,\n} from '@metamask/message-manager';\nimport type { PreferencesController } from '@metamask/preferences-controller';\nimport type { Eip1024EncryptedData, Hex, Keyring, Json } from '@metamask/utils';\nimport { assertIsStrictHexString, hasProperty } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport {\n  addHexPrefix,\n  bufferToHex,\n  isValidPrivate,\n  toBuffer,\n  stripHexPrefix,\n  getBinarySize,\n} from 'ethereumjs-util';\nimport Wallet, { thirdparty as importers } from 'ethereumjs-wallet';\nimport type { Patch } from 'immer';\n\nconst name = 'KeyringController';\n\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n  simple = 'Simple Key Pair',\n  hd = 'HD Key Tree',\n  qr = 'QR Hardware Wallet Device',\n  trezor = 'Trezor Hardware',\n  ledger = 'Ledger Hardware',\n  lattice = 'Lattice Hardware',\n  snap = 'Snap Keyring',\n  custody = 'Custody',\n}\n\n/**\n * @type KeyringControllerState\n *\n * Keyring controller state\n * @property vault - Encrypted string representing keyring data\n * @property isUnlocked - Whether vault is unlocked\n * @property keyringTypes - Account types\n * @property keyrings - Group of accounts\n * @property encryptionKey - Keyring encryption key\n * @property encryptionSalt - Keyring encryption salt\n */\nexport type KeyringControllerState = {\n  vault?: string;\n  isUnlocked: boolean;\n  keyrings: KeyringObject[];\n  encryptionKey?: string;\n  encryptionSalt?: string;\n};\n\nexport type KeyringControllerMemState = Omit<\n  KeyringControllerState,\n  'vault' | 'encryptionKey' | 'encryptionSalt'\n>;\n\nexport type KeyringControllerGetStateAction = {\n  type: `${typeof name}:getState`;\n  handler: () => KeyringControllerState;\n};\n\nexport type KeyringControllerSignMessageAction = {\n  type: `${typeof name}:signMessage`;\n  handler: KeyringController['signMessage'];\n};\n\nexport type KeyringControllerSignPersonalMessageAction = {\n  type: `${typeof name}:signPersonalMessage`;\n  handler: KeyringController['signPersonalMessage'];\n};\n\nexport type KeyringControllerSignTypedMessageAction = {\n  type: `${typeof name}:signTypedMessage`;\n  handler: KeyringController['signTypedMessage'];\n};\n\nexport type KeyringControllerDecryptMessageAction = {\n  type: `${typeof name}:decryptMessage`;\n  handler: KeyringController['decryptMessage'];\n};\n\nexport type KeyringControllerGetEncryptionPublicKeyAction = {\n  type: `${typeof name}:getEncryptionPublicKey`;\n  handler: KeyringController['getEncryptionPublicKey'];\n};\n\nexport type KeyringControllerGetKeyringsByTypeAction = {\n  type: `${typeof name}:getKeyringsByType`;\n  handler: KeyringController['getKeyringsByType'];\n};\n\nexport type KeyringControllerGetKeyringForAccountAction = {\n  type: `${typeof name}:getKeyringForAccount`;\n  handler: KeyringController['getKeyringForAccount'];\n};\n\nexport type KeyringControllerGetAccountsAction = {\n  type: `${typeof name}:getAccounts`;\n  handler: KeyringController['getAccounts'];\n};\n\nexport type KeyringControllerStateChangeEvent = {\n  type: `${typeof name}:stateChange`;\n  payload: [KeyringControllerState, Patch[]];\n};\n\nexport type KeyringControllerAccountRemovedEvent = {\n  type: `${typeof name}:accountRemoved`;\n  payload: [string];\n};\n\nexport type KeyringControllerLockEvent = {\n  type: `${typeof name}:lock`;\n  payload: [];\n};\n\nexport type KeyringControllerUnlockEvent = {\n  type: `${typeof name}:unlock`;\n  payload: [];\n};\n\nexport type KeyringControllerQRKeyringStateChangeEvent = {\n  type: `${typeof name}:qrKeyringStateChange`;\n  payload: [ReturnType<IQRKeyringState['getState']>];\n};\n\nexport type KeyringControllerActions =\n  | KeyringControllerGetStateAction\n  | KeyringControllerSignMessageAction\n  | KeyringControllerSignPersonalMessageAction\n  | KeyringControllerSignTypedMessageAction\n  | KeyringControllerDecryptMessageAction\n  | KeyringControllerGetEncryptionPublicKeyAction\n  | KeyringControllerGetAccountsAction\n  | KeyringControllerGetKeyringsByTypeAction\n  | KeyringControllerGetKeyringForAccountAction;\n\nexport type KeyringControllerEvents =\n  | KeyringControllerStateChangeEvent\n  | KeyringControllerLockEvent\n  | KeyringControllerUnlockEvent\n  | KeyringControllerAccountRemovedEvent\n  | KeyringControllerQRKeyringStateChangeEvent;\n\nexport type KeyringControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  KeyringControllerActions,\n  KeyringControllerEvents,\n  string,\n  string\n>;\n\nexport type KeyringControllerOptions = {\n  syncIdentities: PreferencesController['syncIdentities'];\n  updateIdentities: PreferencesController['updateIdentities'];\n  setSelectedAddress: PreferencesController['setSelectedAddress'];\n  setAccountLabel?: PreferencesController['setAccountLabel'];\n  encryptor?: any;\n  keyringBuilders?: { (): Keyring<Json>; type: string }[];\n  cacheEncryptionKey?: boolean;\n  messenger: KeyringControllerMessenger;\n  state?: { vault?: string };\n};\n\n/**\n * @type KeyringObject\n *\n * Keyring object to return in fullUpdate\n * @property type - Keyring type\n * @property accounts - Associated accounts\n */\nexport type KeyringObject = {\n  accounts: string[];\n  type: string;\n};\n\n/**\n * A strategy for importing an account\n */\nexport enum AccountImportStrategy {\n  privateKey = 'privateKey',\n  json = 'json',\n}\n\n/**\n * The `signTypedMessage` version\n *\n * @see https://docs.metamask.io/guide/signing-data.html\n */\nexport enum SignTypedDataVersion {\n  V1 = 'V1',\n  V3 = 'V3',\n  V4 = 'V4',\n}\n\nconst defaultState: KeyringControllerState = {\n  isUnlocked: false,\n  keyrings: [],\n};\n\n/**\n * Assert that the given keyring has an exportable\n * mnemonic.\n *\n * @param keyring - The keyring to check\n * @throws When the keyring does not have a mnemonic\n */\nfunction assertHasUint8ArrayMnemonic(\n  keyring: Keyring<Json>,\n): asserts keyring is Keyring<Json> & { mnemonic: Uint8Array } {\n  if (\n    !(\n      hasProperty(keyring, 'mnemonic') && keyring.mnemonic instanceof Uint8Array\n    )\n  ) {\n    throw new Error(\"Can't get mnemonic bytes from keyring\");\n  }\n}\n\n/**\n * Controller responsible for establishing and managing user identity.\n *\n * This class is a wrapper around the `eth-keyring-controller` package. The\n * `eth-keyring-controller` manages the \"vault\", which is an encrypted store of private keys, and\n * it manages the wallet \"lock\" state. This wrapper class has convenience methods for interacting\n * with the internal keyring controller and handling certain complex operations that involve the\n * keyrings.\n */\nexport class KeyringController extends BaseControllerV2<\n  typeof name,\n  KeyringControllerState,\n  KeyringControllerMessenger\n> {\n  private readonly mutex = new Mutex();\n\n  private readonly syncIdentities: PreferencesController['syncIdentities'];\n\n  private readonly updateIdentities: PreferencesController['updateIdentities'];\n\n  private readonly setSelectedAddress: PreferencesController['setSelectedAddress'];\n\n  private readonly setAccountLabel?: PreferencesController['setAccountLabel'];\n\n  #keyring: EthKeyringController;\n\n  #qrKeyringStateListener?: (\n    state: ReturnType<IQRKeyringState['getState']>,\n  ) => void;\n\n  /**\n   * Creates a KeyringController instance.\n   *\n   * @param opts - Initial options used to configure this controller\n   * @param opts.syncIdentities - Sync identities with the given list of addresses.\n   * @param opts.updateIdentities - Generate an identity for each address given that doesn't already have an identity.\n   * @param opts.setSelectedAddress - Set the selected address.\n   * @param opts.setAccountLabel - Set a new name for account.\n   * @param opts.encryptor - An optional object for defining encryption schemes.\n   * @param opts.keyringBuilders - Set a new name for account.\n   * @param opts.cacheEncryptionKey - Whether to cache or not encryption key.\n   * @param opts.messenger - A restricted controller messenger.\n   * @param opts.state - Initial state to set on this controller.\n   */\n  constructor({\n    syncIdentities,\n    updateIdentities,\n    setSelectedAddress,\n    setAccountLabel,\n    encryptor,\n    keyringBuilders,\n    cacheEncryptionKey = false,\n    messenger,\n    state,\n  }: KeyringControllerOptions) {\n    super({\n      name,\n      metadata: {\n        vault: { persist: true, anonymous: false },\n        isUnlocked: { persist: false, anonymous: true },\n        keyrings: { persist: false, anonymous: false },\n        encryptionKey: { persist: false, anonymous: false },\n        encryptionSalt: { persist: false, anonymous: false },\n      },\n      messenger,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n\n    this.#keyring = new EthKeyringController({\n      initState: state,\n      encryptor,\n      keyringBuilders,\n      cacheEncryptionKey,\n    });\n    this.#keyring.memStore.subscribe(this.#fullUpdate.bind(this));\n    this.#keyring.store.subscribe(this.#fullUpdate.bind(this));\n    this.#keyring.on('lock', this.#handleLock.bind(this));\n    this.#keyring.on('unlock', this.#handleUnlock.bind(this));\n\n    this.syncIdentities = syncIdentities;\n    this.updateIdentities = updateIdentities;\n    this.setSelectedAddress = setSelectedAddress;\n    this.setAccountLabel = setAccountLabel;\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring.\n   *\n   * @param accountCount - Number of accounts before adding a new one, used to\n   * make the method idempotent.\n   * @returns Promise resolving to keyring current state and added account\n   * address.\n   */\n  async addNewAccount(accountCount?: number): Promise<{\n    keyringState: KeyringControllerMemState;\n    addedAccountAddress: string;\n  }> {\n    const primaryKeyring = this.#keyring.getKeyringsByType('HD Key Tree')[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found');\n    }\n    const oldAccounts = await this.#keyring.getAccounts();\n\n    if (accountCount && oldAccounts.length !== accountCount) {\n      if (accountCount > oldAccounts.length) {\n        throw new Error('Account out of sequence');\n      }\n      // we return the account already existing at index `accountCount`\n      const primaryKeyringAccounts = await primaryKeyring.getAccounts();\n      return {\n        keyringState: this.#getMemState(),\n        addedAccountAddress: primaryKeyringAccounts[accountCount],\n      };\n    }\n\n    await this.#keyring.addNewAccount(primaryKeyring);\n    const newAccounts = await this.#keyring.getAccounts();\n\n    await this.verifySeedPhrase();\n\n    this.updateIdentities(newAccounts);\n    const addedAccountAddress = newAccounts.find(\n      (selectedAddress: string) => !oldAccounts.includes(selectedAddress),\n    );\n\n    assertIsStrictHexString(addedAccountAddress);\n    return {\n      keyringState: this.#getMemState(),\n      addedAccountAddress,\n    };\n  }\n\n  /**\n   * Adds a new account to the specified keyring.\n   *\n   * @param keyring - Keyring to add the account to.\n   * @param accountCount - Number of accounts before adding a new one, used to make the method idempotent.\n   * @returns Promise resolving to keyring current state and added account\n   */\n  async addNewAccountForKeyring(\n    keyring: Keyring<Json>,\n    accountCount?: number,\n  ): Promise<Hex> {\n    const oldAccounts = await this.getAccounts();\n\n    if (accountCount && oldAccounts.length !== accountCount) {\n      if (accountCount > oldAccounts.length) {\n        throw new Error('Account out of sequence');\n      }\n\n      const existingAccount = oldAccounts[accountCount];\n      assertIsStrictHexString(existingAccount);\n\n      return existingAccount;\n    }\n\n    await this.#keyring.addNewAccount(keyring);\n    const addedAccountAddress = (await this.getAccounts()).find(\n      (selectedAddress) => !oldAccounts.includes(selectedAddress),\n    );\n    assertIsStrictHexString(addedAccountAddress);\n\n    this.updateIdentities(await this.#keyring.getAccounts());\n\n    return addedAccountAddress;\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.\n   *\n   * @returns Promise resolving to current state when the account is added.\n   */\n  async addNewAccountWithoutUpdate(): Promise<KeyringControllerMemState> {\n    const primaryKeyring = this.#keyring.getKeyringsByType('HD Key Tree')[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found');\n    }\n    await this.#keyring.addNewAccount(primaryKeyring);\n    await this.verifySeedPhrase();\n    return this.#getMemState();\n  }\n\n  /**\n   * Effectively the same as creating a new keychain then populating it\n   * using the given seed phrase.\n   *\n   * @param password - Password to unlock keychain.\n   * @param seed - A BIP39-compliant seed phrase as Uint8Array,\n   * either as a string or an array of UTF-8 bytes that represent the string.\n   * @returns Promise resolving to the restored keychain object.\n   */\n  async createNewVaultAndRestore(\n    password: string,\n    seed: Uint8Array,\n  ): Promise<KeyringControllerMemState> {\n    const releaseLock = await this.mutex.acquire();\n    if (!password || !password.length) {\n      throw new Error('Invalid password');\n    }\n\n    try {\n      this.updateIdentities([]);\n      await this.#keyring.createNewVaultAndRestore(password, seed);\n      this.updateIdentities(await this.#keyring.getAccounts());\n      return this.#getMemState();\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Create a new primary keychain and wipe any previous keychains.\n   *\n   * @param password - Password to unlock the new vault.\n   * @returns Newly-created keychain object.\n   */\n  async createNewVaultAndKeychain(password: string) {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const accounts = await this.getAccounts();\n      if (!accounts.length) {\n        await this.#keyring.createNewVaultAndKeychain(password);\n        this.updateIdentities(await this.getAccounts());\n      }\n      return this.#getMemState();\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds a new keyring of the given `type`.\n   *\n   * @param type - Keyring type name.\n   * @param opts - Keyring options.\n   * @throws If a builder for the given `type` does not exist.\n   * @returns Promise resolving to the added keyring.\n   */\n  async addNewKeyring(\n    type: KeyringTypes | string,\n    opts?: unknown,\n  ): Promise<unknown> {\n    if (type === KeyringTypes.qr) {\n      return this.getOrAddQRKeyring();\n    }\n\n    return this.#keyring.addNewKeyring(type, opts);\n  }\n\n  /**\n   * Method to verify a given password validity. Throws an\n   * error if the password is invalid.\n   *\n   * @param password - Password of the keyring.\n   */\n  async verifyPassword(password: string) {\n    await this.#keyring.verifyPassword(password);\n  }\n\n  /**\n   * Returns the status of the vault.\n   *\n   * @returns Boolean returning true if the vault is unlocked.\n   */\n  isUnlocked(): boolean {\n    return this.state.isUnlocked;\n  }\n\n  /**\n   * Gets the seed phrase of the HD keyring.\n   *\n   * @param password - Password of the keyring.\n   * @returns Promise resolving to the seed phrase.\n   */\n  async exportSeedPhrase(password: string): Promise<Uint8Array> {\n    await this.verifyPassword(password);\n    assertHasUint8ArrayMnemonic(this.#keyring.keyrings[0]);\n    return this.#keyring.keyrings[0].mnemonic;\n  }\n\n  /**\n   * Gets the private key from the keyring controlling an address.\n   *\n   * @param password - Password of the keyring.\n   * @param address - Address to export.\n   * @returns Promise resolving to the private key for an address.\n   */\n  async exportAccount(password: string, address: string): Promise<string> {\n    await this.verifyPassword(password);\n    return this.#keyring.exportAccount(address);\n  }\n\n  /**\n   * Returns the public addresses of all accounts for the current keyring.\n   *\n   * @returns A promise resolving to an array of addresses.\n   */\n  getAccounts(): Promise<string[]> {\n    return this.#keyring.getAccounts();\n  }\n\n  /**\n   * Get encryption public key.\n   *\n   * @param account - An account address.\n   * @param opts - Additional encryption options.\n   * @throws If the `account` does not exist or does not support the `getEncryptionPublicKey` method\n   * @returns Promise resolving to encyption public key of the `account` if one exists.\n   */\n  async getEncryptionPublicKey(\n    account: string,\n    opts?: Record<string, unknown>,\n  ): Promise<string> {\n    return this.#keyring.getEncryptionPublicKey(account, opts);\n  }\n\n  /**\n   * Attempts to decrypt the provided message parameters.\n   *\n   * @param messageParams - The decryption message parameters.\n   * @param messageParams.from - The address of the account you want to use to decrypt the message.\n   * @param messageParams.data - The encrypted data that you want to decrypt.\n   * @returns The raw decryption result.\n   */\n  async decryptMessage(messageParams: {\n    from: string;\n    data: Eip1024EncryptedData;\n  }): Promise<string> {\n    return this.#keyring.decryptMessage(messageParams);\n  }\n\n  /**\n   * Returns the currently initialized keyring that manages\n   * the specified `address` if one exists.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault.\n   * @param account - An account address.\n   * @returns Promise resolving to keyring of the `account` if one exists.\n   */\n  async getKeyringForAccount(account: string): Promise<unknown> {\n    return this.#keyring.getKeyringForAccount(account);\n  }\n\n  /**\n   * Returns all keyrings of the given type.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault.\n   * @param type - Keyring type name.\n   * @returns An array of keyrings of the given type.\n   */\n  getKeyringsByType(type: KeyringTypes | string): unknown[] {\n    return this.#keyring.getKeyringsByType(type);\n  }\n\n  /**\n   * Persist all serialized keyrings in the vault.\n   *\n   * @returns Promise resolving with `true` value when the\n   * operation completes.\n   */\n  async persistAllKeyrings(): Promise<boolean> {\n    return this.#keyring.persistAllKeyrings();\n  }\n\n  /**\n   * Imports an account with the specified import strategy.\n   *\n   * @param strategy - Import strategy name.\n   * @param args - Array of arguments to pass to the underlying stategy.\n   * @throws Will throw when passed an unrecognized strategy.\n   * @returns Promise resolving to keyring current state and imported account\n   * address.\n   */\n  async importAccountWithStrategy(\n    strategy: AccountImportStrategy,\n    args: any[],\n  ): Promise<{\n    keyringState: KeyringControllerMemState;\n    importedAccountAddress: string;\n  }> {\n    let privateKey;\n    switch (strategy) {\n      case 'privateKey':\n        const [importedKey] = args;\n        if (!importedKey) {\n          throw new Error('Cannot import an empty key.');\n        }\n        const prefixed = addHexPrefix(importedKey);\n\n        let bufferedPrivateKey;\n        try {\n          bufferedPrivateKey = toBuffer(prefixed);\n        } catch {\n          throw new Error('Cannot import invalid private key.');\n        }\n\n        /* istanbul ignore if */\n        if (\n          !isValidPrivate(bufferedPrivateKey) ||\n          // ensures that the key is 64 bytes long\n          getBinarySize(prefixed) !== 64 + '0x'.length\n        ) {\n          throw new Error('Cannot import invalid private key.');\n        }\n\n        privateKey = stripHexPrefix(prefixed);\n        break;\n      case 'json':\n        let wallet;\n        const [input, password] = args;\n        try {\n          wallet = importers.fromEtherWallet(input, password);\n        } catch (e) {\n          wallet = wallet || (await Wallet.fromV3(input, password, true));\n        }\n        privateKey = bufferToHex(wallet.getPrivateKey());\n        break;\n      default:\n        throw new Error(`Unexpected import strategy: '${strategy}'`);\n    }\n    const newKeyring = await this.#keyring.addNewKeyring(KeyringTypes.simple, [\n      privateKey,\n    ]);\n    const accounts = await newKeyring.getAccounts();\n    const allAccounts = await this.#keyring.getAccounts();\n    this.updateIdentities(allAccounts);\n    return {\n      keyringState: this.#getMemState(),\n      importedAccountAddress: accounts[0],\n    };\n  }\n\n  /**\n   * Removes an account from keyring state.\n   *\n   * @param address - Address of the account to remove.\n   * @fires KeyringController:accountRemoved\n   * @returns Promise resolving current state when this account removal completes.\n   */\n  async removeAccount(address: Hex): Promise<KeyringControllerMemState> {\n    await this.#keyring.removeAccount(address);\n    this.messagingSystem.publish(`${name}:accountRemoved`, address);\n    return this.#getMemState();\n  }\n\n  /**\n   * Deallocates all secrets and locks the wallet.\n   *\n   * @returns Promise resolving to current state.\n   */\n  async setLocked(): Promise<KeyringControllerMemState> {\n    this.#unsubscribeFromQRKeyringsEvents();\n    await this.#keyring.setLocked();\n    return this.#getMemState();\n  }\n\n  /**\n   * Signs message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  signMessage(messageParams: PersonalMessageParams) {\n    if (!messageParams.data) {\n      throw new Error(\"Can't sign an empty message\");\n    }\n    return this.#keyring.signMessage(messageParams);\n  }\n\n  /**\n   * Signs personal message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  signPersonalMessage(messageParams: PersonalMessageParams) {\n    return this.#keyring.signPersonalMessage(messageParams);\n  }\n\n  /**\n   * Signs typed message by calling down into a specific keyring.\n   *\n   * @param messageParams - TypedMessageParams object to sign.\n   * @param version - Compatibility version EIP712.\n   * @throws Will throw when passed an unrecognized version.\n   * @returns Promise resolving to a signed message string or an error if any.\n   */\n  async signTypedMessage(\n    messageParams: TypedMessageParams,\n    version: SignTypedDataVersion,\n  ): Promise<string> {\n    try {\n      if (\n        ![\n          SignTypedDataVersion.V1,\n          SignTypedDataVersion.V3,\n          SignTypedDataVersion.V4,\n        ].includes(version)\n      ) {\n        throw new Error(`Unexpected signTypedMessage version: '${version}'`);\n      }\n\n      return await this.#keyring.signTypedMessage(\n        {\n          from: messageParams.from,\n          data:\n            version !== SignTypedDataVersion.V1 &&\n            typeof messageParams.data === 'string'\n              ? JSON.parse(messageParams.data)\n              : messageParams.data,\n        },\n        { version },\n      );\n    } catch (error) {\n      throw new Error(`Keyring Controller signTypedMessage: ${error}`);\n    }\n  }\n\n  /**\n   * Signs a transaction by calling down into a specific keyring.\n   *\n   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.\n   * @param from - Address to sign from, should be in keychain.\n   * @param opts - An optional options object.\n   * @returns Promise resolving to a signed transaction string.\n   */\n  signTransaction(\n    transaction: TypedTransaction,\n    from: string,\n    opts?: Record<string, unknown>,\n  ): Promise<TxData> {\n    return this.#keyring.signTransaction(transaction, from, opts);\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given encryption key and salt.\n   *\n   * @param encryptionKey - Key to unlock the keychain.\n   * @param encryptionSalt - Salt to unlock the keychain.\n   * @returns Promise resolving to the current state.\n   */\n  async submitEncryptionKey(\n    encryptionKey: string,\n    encryptionSalt: string,\n  ): Promise<KeyringControllerMemState> {\n    await this.#keyring.submitEncryptionKey(encryptionKey, encryptionSalt);\n\n    const qrKeyring = this.getQRKeyring();\n    if (qrKeyring) {\n      // if there is a QR keyring, we need to subscribe\n      // to its events after unlocking the vault\n      this.#subscribeToQRKeyringEvents(qrKeyring);\n    }\n\n    return this.#getMemState();\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given password.\n   *\n   * @param password - Password to unlock the keychain.\n   * @returns Promise resolving to the current state.\n   */\n  async submitPassword(password: string): Promise<KeyringControllerMemState> {\n    await this.#keyring.submitPassword(password);\n    const accounts = await this.#keyring.getAccounts();\n\n    const qrKeyring = this.getQRKeyring();\n    if (qrKeyring) {\n      // if there is a QR keyring, we need to subscribe\n      // to its events after unlocking the vault\n      this.#subscribeToQRKeyringEvents(qrKeyring);\n    }\n\n    await this.syncIdentities(accounts);\n    return this.#getMemState();\n  }\n\n  /**\n   * Verifies the that the seed phrase restores the current keychain's accounts.\n   *\n   * @returns Promise resolving to the seed phrase as Uint8Array.\n   */\n  async verifySeedPhrase(): Promise<Uint8Array> {\n    const primaryKeyring = this.#keyring.getKeyringsByType(KeyringTypes.hd)[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found.');\n    }\n\n    assertHasUint8ArrayMnemonic(primaryKeyring);\n\n    const seedWords = primaryKeyring.mnemonic;\n    const accounts = await primaryKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (accounts.length === 0) {\n      throw new Error('Cannot verify an empty keyring.');\n    }\n\n    // The HD Keyring Builder is a default keyring builder\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const hdKeyringBuilder = this.#keyring.getKeyringBuilderForType(\n      KeyringTypes.hd,\n    )!;\n\n    const hdKeyring = hdKeyringBuilder();\n    // @ts-expect-error @metamask/eth-hd-keyring correctly handles\n    // Uint8Array seed phrases in the `deserialize` method.\n    hdKeyring.deserialize({\n      mnemonic: seedWords,\n      numberOfAccounts: accounts.length,\n    });\n    const testAccounts = await hdKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (testAccounts.length !== accounts.length) {\n      throw new Error('Seed phrase imported incorrect number of accounts.');\n    }\n\n    testAccounts.forEach((account: string, i: number) => {\n      /* istanbul ignore if */\n      if (account.toLowerCase() !== accounts[i].toLowerCase()) {\n        throw new Error('Seed phrase imported different accounts.');\n      }\n    });\n\n    return seedWords;\n  }\n\n  // QR Hardware related methods\n\n  /**\n   * Get QR Hardware keyring.\n   *\n   * @returns The QR Keyring if defined, otherwise undefined\n   */\n  getQRKeyring(): QRKeyring | undefined {\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return this.#keyring.getKeyringsByType(\n      KeyringTypes.qr,\n    )[0] as unknown as QRKeyring;\n  }\n\n  /**\n   * Get QR hardware keyring. If it doesn't exist, add it.\n   *\n   * @returns The added keyring\n   */\n  async getOrAddQRKeyring(): Promise<QRKeyring> {\n    return this.getQRKeyring() || (await this.#addQRKeyring());\n  }\n\n  async restoreQRKeyring(serialized: any): Promise<void> {\n    (await this.getOrAddQRKeyring()).deserialize(serialized);\n    await this.#keyring.persistAllKeyrings();\n    this.updateIdentities(await this.#keyring.getAccounts());\n  }\n\n  async resetQRKeyringState(): Promise<void> {\n    (await this.getOrAddQRKeyring()).resetStore();\n  }\n\n  async getQRKeyringState(): Promise<IQRKeyringState> {\n    return (await this.getOrAddQRKeyring()).getMemStore();\n  }\n\n  async submitQRCryptoHDKey(cryptoHDKey: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);\n  }\n\n  async submitQRCryptoAccount(cryptoAccount: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);\n  }\n\n  async submitQRSignature(\n    requestId: string,\n    ethSignature: string,\n  ): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);\n  }\n\n  async cancelQRSignRequest(): Promise<void> {\n    (await this.getOrAddQRKeyring()).cancelSignRequest();\n  }\n\n  /**\n   * Cancels qr keyring sync.\n   */\n  async cancelQRSynchronization(): Promise<void> {\n    // eslint-disable-next-line n/no-sync\n    (await this.getOrAddQRKeyring()).cancelSync();\n  }\n\n  async connectQRHardware(\n    page: number,\n  ): Promise<{ balance: string; address: string; index: number }[]> {\n    try {\n      const keyring = await this.getOrAddQRKeyring();\n      let accounts;\n      switch (page) {\n        case -1:\n          accounts = await keyring.getPreviousPage();\n          break;\n        case 1:\n          accounts = await keyring.getNextPage();\n          break;\n        default:\n          accounts = await keyring.getFirstPage();\n      }\n      return accounts.map((account: any) => {\n        return {\n          ...account,\n          balance: '0x0',\n        };\n      });\n    } catch (e) {\n      // TODO: Add test case for when keyring throws\n      /* istanbul ignore next */\n      throw new Error(`Unspecified error when connect QR Hardware, ${e}`);\n    }\n  }\n\n  async unlockQRHardwareWalletAccount(index: number): Promise<void> {\n    const keyring = await this.getOrAddQRKeyring();\n\n    keyring.setAccountToUnlock(index);\n    const oldAccounts = await this.#keyring.getAccounts();\n    // QRKeyring is not yet compatible with Keyring from\n    // @metamask/utils, but we can use the `addNewAccount` method\n    // as it internally calls `addAccounts` from on the keyring instance,\n    // which is supported by QRKeyring API.\n    await this.#keyring.addNewAccount(keyring as unknown as Keyring<Json>);\n    const newAccounts = await this.#keyring.getAccounts();\n    this.updateIdentities(newAccounts);\n    newAccounts.forEach((address: string) => {\n      if (!oldAccounts.includes(address)) {\n        if (this.setAccountLabel) {\n          this.setAccountLabel(address, `${keyring.getName()} ${index}`);\n        }\n        this.setSelectedAddress(address);\n      }\n    });\n    await this.#keyring.persistAllKeyrings();\n  }\n\n  async getAccountKeyringType(account: string): Promise<string> {\n    return (await this.#keyring.getKeyringForAccount(account)).type;\n  }\n\n  async forgetQRDevice(): Promise<void> {\n    const keyring = await this.getOrAddQRKeyring();\n    keyring.forgetDevice();\n    const accounts = (await this.#keyring.getAccounts()) as string[];\n    accounts.forEach((account) => {\n      this.setSelectedAddress(account);\n    });\n    await this.#keyring.persistAllKeyrings();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers() {\n    this.messagingSystem.registerActionHandler(\n      `${name}:signMessage`,\n      this.signMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signPersonalMessage`,\n      this.signPersonalMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signTypedMessage`,\n      this.signTypedMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:decryptMessage`,\n      this.decryptMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getEncryptionPublicKey`,\n      this.getEncryptionPublicKey.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getAccounts`,\n      this.getAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringsByType`,\n      this.getKeyringsByType.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringForAccount`,\n      this.getKeyringForAccount.bind(this),\n    );\n  }\n\n  /**\n   * Add qr hardware keyring.\n   *\n   * @returns The added keyring\n   * @throws If a QRKeyring builder is not provided\n   * when initializing the controller\n   */\n  async #addQRKeyring(): Promise<QRKeyring> {\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    const qrKeyring = (await this.#keyring.addNewKeyring(\n      KeyringTypes.qr,\n    )) as unknown as QRKeyring;\n\n    this.#subscribeToQRKeyringEvents(qrKeyring);\n\n    return qrKeyring;\n  }\n\n  /**\n   * Subscribe to a QRKeyring state change events and\n   * forward them through the messaging system.\n   *\n   * @param qrKeyring - The QRKeyring instance to subscribe to\n   */\n  #subscribeToQRKeyringEvents(qrKeyring: QRKeyring) {\n    this.#qrKeyringStateListener = (state) => {\n      this.messagingSystem.publish(`${name}:qrKeyringStateChange`, state);\n    };\n\n    qrKeyring.getMemStore().subscribe(this.#qrKeyringStateListener);\n  }\n\n  #unsubscribeFromQRKeyringsEvents() {\n    const qrKeyrings = this.#keyring.getKeyringsByType(\n      KeyringTypes.qr,\n    ) as unknown as QRKeyring[];\n\n    qrKeyrings.forEach((qrKeyring) => {\n      if (this.#qrKeyringStateListener) {\n        qrKeyring.getMemStore().unsubscribe(this.#qrKeyringStateListener);\n      }\n    });\n  }\n\n  /**\n   * Sync controller state with current keyring store\n   * and memStore states.\n   *\n   * @fires KeyringController:stateChange\n   */\n  #fullUpdate() {\n    const { vault } = this.#keyring.store.getState();\n    const { keyrings, isUnlocked, encryptionKey, encryptionSalt } =\n      this.#keyring.memStore.getState();\n\n    this.update(() => ({\n      vault,\n      keyrings,\n      isUnlocked,\n      encryptionKey,\n      encryptionSalt,\n    }));\n  }\n\n  /**\n   * Handle keyring lock event.\n   *\n   * @fires KeyringController:lock\n   */\n  #handleLock() {\n    this.messagingSystem.publish(`${name}:lock`);\n  }\n\n  /**\n   * Handle keyring unlock event.\n   *\n   * @fires KeyringController:unlock\n   */\n  #handleUnlock() {\n    this.messagingSystem.publish(`${name}:unlock`);\n  }\n\n  #getMemState(): KeyringControllerMemState {\n    return {\n      isUnlocked: this.state.isUnlocked,\n      keyrings: this.state.keyrings,\n    };\n  }\n}\n\nexport default KeyringController;\n"]}